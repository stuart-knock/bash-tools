#!/usr/bin/env bash

#USAGE:
#  #Source the file to get access to all the variable and function definitions.
#  source bashlogging [LogType]
#  #LogType argument ['stdout'|'stderr'|'file'|'stdoutfile'(default)|'stderrfile']
#  #directs output to stdout, file or both. This can only be set while "source"ing.
#  #Then you can override default LogFile and LogLevel to suit your needs.
#  LogFile='path/to/mylogfile.log'
#  LogLevel=3  #I have a problem with my script that I need to identify.
#  myfunc(){
#    #Then all that is left is to cover your script and functions with 
#    #useful messages:
#    Debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
#    DebugCont "Called with $# arguments"
#    local i=0 ; for var in "$@"; do ((++i)) ; DebugCont "arg $i = ${var}"; done
#    #DebugCont "arg 1 = $1"
#    #DebugCont "arg 2 = $2"
#    #DebugCont "arg 3 = $3"
#    DebugCont "ImportantGlobalParamater = $ImportantGlobalParamater"
#    Inform 'That important thing is being calculated now...'
#    #You can pipe another commands stdout to your logs
#    command1 | err_pipe "command1: "
#    #Or with stderr as well
#    command1 2>&1 | err_pipe "command1: "
#    #If using one of the stderr or file-only LogTypes, you can message mid pipe
#    command1 | tee >(Debug "Stuff is happening") | command2
#    Warn 'The ducks weren't all in a row, but we'll forge on.'
#    Err 'It all went horribly wrong, no value will be returned.'
#    ErrCont "The value of x was $y and j was $z, try passing q to ${FUNCNAME}()"
#    ErrCont "You may also need to 'chmod a+rwx yourfile.txt' and do a rain dance."
#  }
#
#REQUIRES:
#  tee -- reads from standard input then writes to standard output & files.
#  xargs
#  bash >= 4
#  GNU sleep -- supporting specification of floating point seconds ie, 0.1 etc.
#
#PROVIDES:
#  #Message functions: for file output, prepends date & time
#  Debug  -- For LogLevel >= 3, writes messages prepended with "DEBUG: "
#  Inform -- For LogLevel >= 2, writes messages prepended with "INFORM: "
#  Warn   -- For LogLevel >= 1, writes messages prepended with "WARNING: "
#  Err    -- For LogLevel >= 0, writes messages prepended with "ERROR: "
#  #Continued/multiline message functions: these are indented without leading info.
#  DebugCont  -- Continues a LogLevel 3 message.
#  InformCont -- Continues a LogLevel 2 message.
#  WarnCont   -- Continues a LogLevel 1 message.
#  ErrCont    -- Continues a LogLevel 0 message.
#  #Pipe output from another command to logs, eg: command 2>&1 | err_pipe "command: "
#  err_pipe -- For LogLevel >= 0, write piped input to logs.
#
#DESCRIPTION:
# Defines a few functions for fine grained control of logging information.
# Writes different types of messages based on LogLevel. The messages are 
# sent to either stdout, stderr, file, or both based on the LogType argument.
# The file output is prepended with date & time -- stdout/stderr aren't.
#
# Author: Stuart A. Knock
# Originally Written: 2015-11-27
#

#TODO: Consider adding an AutoElevate ['Enabled'|'Disabled'] option, which automatically raises 
#      the LogLevel to 2 in the event of warnings and 3 in the event of errors.
#TODO: Consider making indentation on Cont[inuation] lines a standard 4 spaces.
#TODO: Enable different "LogLevel"s for file and stdout.
#TODO: the fraction of a second sleep works for GNU/Linux sleep, but not necessarily others... Solve order preservation some other way...
#TODO: Consider copying stderr generated by the script to log file: see http://stackoverflow.com/questions/637827/redirect-stderr-and-stdout-in-a-bash-script
#    exec 4>&2 2> >(tee >(xargs --null printf "[$(date +%FT%T)] ERROR: %s\n" >> "$LogFile") >&4)
#TODO: Consider conforming to this: https://google.github.io/styleguide/shell.xml
#      variable names ALLCAPS, function names all_lower_case
#TODO: Consider whether it's worth making the functions readonly to avoid accidental modification.

#Default logging level, controls the type of bashlogging messages reported.
#This can be modified at any point in a calling script to increase/decrease
#the amount of information reported based on context.
#    0=Only Errors;
#    1=adds warnings;
#    2=adds more information;
#    3=provides debugging output.
if [[ -z "$LogLevel" ]]; then declare -gi LogLevel=2; else declare -gi LogLevel; fi

#Default log file name, only set if one isn't already 
[[ -z "$LogFile" ]] && LogFile='default_bashlogging.log'

#Default type of logging to do, or more specifically the type of destination
#for logging messages. Options are ['logfile'|'stdout'|'both'(default)], the
#default set here can only be overridden when source[ing] bashlogging, eg:
#    source bashlogging 'logfile' #Only send logging messages to file, not stdout.
#and not after sourcing, as can be done with LogLevel and LogFile.
[[ -z "$LogType" ]] && LogType='both'

#^^^^----------- DEFAULT USER SETTINGS ABOVE THIS LINE ------------------^^^^#

declare -gr pad='           ' #needs to be >= number of spaces for the largest X below in %0.Xs
declare -gr DEBUG_CLR='\e[1;32mDEBUG:\e[0m'  # Bold Green
declare -gr INFO_CLR='\e[1;34mINFO:\e[0m'    # Bold Blue
declare -gr WARN_CLR='\e[1;33mWARNING:\e[0m' # Bold Yellow-ish
declare -gr ERROR_CLR='\e[1;31mERROR:\e[0m'  # Bold Red
declare -gr STRIP_CLR='s/\x1B\[([0-1];)?[0-4]{1,2}m//g' #A regex to strip colour tags

#Make sure we were sourced with a reasonable number of args, return with error message if we weren't.
(($# > 1)) && { printf "$ERROR_CLR %s\n" "${BASH_SOURCE[0]} takes at most 1 arg" ; return 1 ; }
#If we were called with an arg use it, either way make LogType readonly so it can't be corrupted.
if (($# == 1)) && [[ "$1" =~ ^(logfile|file|stdout|stderr|both|filestdout|filestderr)$ ]] ; then
  declare -gr LogType="$1"
elif (($# == 0)) && [[ "$LogType" =~ ^(logfile|file|stdout|stderr|both|filestdout|filestderr)$ ]] ; then
  declare -gr LogType
else
  printf "$ERROR_CLR %s\n" "For ${BASH_SOURCE[0]} LogType must be 'logfile'|'stdout'|'both'."
  return 1
fi

if [[ "$LogType" = @(both|filestdout) ]] ; then
  #Functions defining the different logging messages, sent to logfile & stdout.
  #sleep is a hack to avoid wrong order in file when *Cont is used, and apparently processes faster leading to out of order file content.
  Debug(){  ((LogLevel >= 3)) && printf "$DEBUG_CLR %s\n" "$1" | tee >(xargs --null printf "[$(date +%FT%T)] %s" | sed -r "$STRIP_CLR" >> "$LogFile"); sleep 0.002; }
  Inform(){ ((LogLevel >= 2)) && printf "$INFO_CLR %s\n"  "$1" | tee >(xargs --null printf "[$(date +%FT%T)] %s" | sed -r "$STRIP_CLR" >> "$LogFile"); sleep 0.002; }
  Warn(){   ((LogLevel >= 1)) && printf "$WARN_CLR %s\n"  "$1" | tee >(xargs --null printf "[$(date +%FT%T)] %s" | sed -r "$STRIP_CLR" >> "$LogFile"); sleep 0.002; }
  Err(){    ((LogLevel >= 0)) && printf "$ERROR_CLR %s\n" "$1" | tee >(xargs --null printf "[$(date +%FT%T)] %s" | sed -r "$STRIP_CLR" >> "$LogFile"); sleep 0.002; }
  #Func: #If LogLevel appropriate #Prepend msg with Type #Pipe to stdout & process substitution: prepend Date&Time, strip colour tags #Redirect to file #Wait so order preserved

  #Use for multiple lines of a single message, sent to logfile & stdout
  DebugCont(){  ((LogLevel >= 3)) && printf '%0.7s%s\n' "$pad" "$1" | tee -a "$LogFile"; }
  InformCont(){ ((LogLevel >= 2)) && printf '%0.6s%s\n' "$pad" "$1" | tee -a "$LogFile"; }
  WarnCont(){   ((LogLevel >= 1)) && printf '%0.9s%s\n' "$pad" "$1" | tee -a "$LogFile"; }
  ErrCont(){    ((LogLevel >= 0)) && printf '%0.7s%s\n' "$pad" "$1" | tee -a "$LogFile"; }

  #Use to pipe output from another command to logs, eg: command 2>&1 | err_pipe "command: "
  err_pipe(){ while IFS='' read -r msg; do msg="$1$msg"; ((LogLevel >= 0)) && printf '%s\n' "$msg" | tee -a "$LogFile"; done; }

elif [[ "$LogType" = 'filestderr' ]] ; then
  #Functions defining the different logging messages, sent to logfile & stderr.
  #sleep is a hack to avoid wrong order in file when *Cont is used, and apparently processes faster leading to out of order file content.
  Debug(){  ((LogLevel >= 3)) && printf "$DEBUG_CLR %s\n" "$1" | tee >(xargs --null printf "[$(date +%FT%T)] %s" | sed -r "$STRIP_CLR" >> "$LogFile") 1>&2 ; sleep 0.002; }
  Inform(){ ((LogLevel >= 2)) && printf "$INFO_CLR %s\n"  "$1" | tee >(xargs --null printf "[$(date +%FT%T)] %s" | sed -r "$STRIP_CLR" >> "$LogFile") 1>&2 ; sleep 0.002; }
  Warn(){   ((LogLevel >= 1)) && printf "$WARN_CLR %s\n"  "$1" | tee >(xargs --null printf "[$(date +%FT%T)] %s" | sed -r "$STRIP_CLR" >> "$LogFile") 1>&2 ; sleep 0.002; }
  Err(){    ((LogLevel >= 0)) && printf "$ERROR_CLR %s\n" "$1" | tee >(xargs --null printf "[$(date +%FT%T)] %s" | sed -r "$STRIP_CLR" >> "$LogFile") 1>&2 ; sleep 0.002; }
  #Func: #If LogLevel appropriate #Prepend msg with Type #Pipe to stderr & process substitution: prepend Date&Time, strip colour tags #Redirect to file #Wait so order preserved

  #Use for multiple lines of a single message, sent to logfile & stderr
  DebugCont(){  ((LogLevel >= 3)) && printf '%0.7s%s\n' "$pad" "$1" | tee -a "$LogFile" 1>&2 ; }
  InformCont(){ ((LogLevel >= 2)) && printf '%0.6s%s\n' "$pad" "$1" | tee -a "$LogFile" 1>&2 ; }
  WarnCont(){   ((LogLevel >= 1)) && printf '%0.9s%s\n' "$pad" "$1" | tee -a "$LogFile" 1>&2 ; }
  ErrCont(){    ((LogLevel >= 0)) && printf '%0.7s%s\n' "$pad" "$1" | tee -a "$LogFile" 1>&2 ; }

  #Use to pipe output from another command to logs, eg: command 2>&1 | err_pipe "command: "
  err_pipe(){ while IFS='' read -r msg; do msg="$1$msg"; ((LogLevel >= 0)) && printf '%s\n' "$msg" | tee -a "$LogFile" 1>&2 ; done; }

elif [[ "$LogType" = 'stdout' ]] ; then
  #Functions defining the different logging messages, no-logfile==only-stdout
  Debug(){  ((LogLevel >= 3)) && printf "$DEBUG_CLR %s\n" "$1" ; }
  Inform(){ ((LogLevel >= 2)) && printf "$INFO_CLR %s\n"  "$1" ; }
  Warn(){   ((LogLevel >= 1)) && printf "$WARN_CLR %s\n"  "$1" ; }
  Err(){    ((LogLevel >= 0)) && printf "$ERROR_CLR %s\n" "$1" ; }

  #Use for multiple lines of a single message, no-logfile==only-stdout
  DebugCont(){  ((LogLevel >= 3)) && printf '%0.7s%s\n' "$pad" "$1" ; }
  InformCont(){ ((LogLevel >= 2)) && printf '%0.6s%s\n' "$pad" "$1" ; }
  WarnCont(){   ((LogLevel >= 1)) && printf '%0.9s%s\n' "$pad" "$1" ; }
  ErrCont(){    ((LogLevel >= 0)) && printf '%0.7s%s\n' "$pad" "$1" ; }

  #Use to pipe output from another command to logs, eg: command 2>&1 | err_pipe "command: "
  err_pipe(){ while IFS='' read -r msg; do msg="$1$msg"; ((LogLevel >= 0)) && printf '%s\n' "$msg" ; done; }

elif [[ "$LogType" = 'stderr' ]] ; then
  #Functions defining the different logging messages, no-logfile==only-stderr
  Debug(){  ((LogLevel >= 3)) && printf "$DEBUG_CLR %s\n" "$1" 1>&2 ; }
  Inform(){ ((LogLevel >= 2)) && printf "$INFO_CLR %s\n"  "$1" 1>&2 ; }
  Warn(){   ((LogLevel >= 1)) && printf "$WARN_CLR %s\n"  "$1" 1>&2 ; }
  Err(){    ((LogLevel >= 0)) && printf "$ERROR_CLR %s\n" "$1" 1>&2 ; }

  #Use for multiple lines of a single message, no-logfile==only-stderr
  DebugCont(){  ((LogLevel >= 3)) && printf '%0.7s%s\n' "$pad" "$1" 1>&2 ; }
  InformCont(){ ((LogLevel >= 2)) && printf '%0.6s%s\n' "$pad" "$1" 1>&2 ; }
  WarnCont(){   ((LogLevel >= 1)) && printf '%0.9s%s\n' "$pad" "$1" 1>&2 ; }
  ErrCont(){    ((LogLevel >= 0)) && printf '%0.7s%s\n' "$pad" "$1" 1>&2 ; }

  #Use to pipe output from another command to logs, eg: command 2>&1 | err_pipe "command: "
  err_pipe(){ while IFS='' read -r msg; do msg="$1$msg"; ((LogLevel >= 0)) && printf '%s\n' "$msg" 1>&2 ; done; }

elif [[ "$LogType" = @(logfile|file) ]] ; then
  #Functions defining the different logging messages, no-stdout|stderr==only-logfile
  Debug(){  ((LogLevel >= 3)) && printf "[$(date +%FT%T)] DEBUG: %s\n"   "$1" >> "$LogFile"; }
  Inform(){ ((LogLevel >= 2)) && printf "[$(date +%FT%T)] INFO: %s\n"    "$1" >> "$LogFile"; }
  Warn(){   ((LogLevel >= 1)) && printf "[$(date +%FT%T)] WARNING: %s\n" "$1" >> "$LogFile"; }
  Err(){    ((LogLevel >= 0)) && printf "[$(date +%FT%T)] ERROR: %s\n"   "$1" >> "$LogFile"; }

  #Use for multiple lines of a single message, no-stdout==only-logfile
  DebugCont(){  ((LogLevel >= 3)) && printf '%0.7s%s\n' "$pad" "$1" >> "$LogFile"; }
  InformCont(){ ((LogLevel >= 2)) && printf '%0.6s%s\n' "$pad" "$1" >> "$LogFile"; }
  WarnCont(){   ((LogLevel >= 1)) && printf '%0.9s%s\n' "$pad" "$1" >> "$LogFile"; }
  ErrCont(){    ((LogLevel >= 0)) && printf '%0.7s%s\n' "$pad" "$1" >> "$LogFile"; }

  #Use to pipe output from another command to logs, eg: command 2>&1 | err_pipe "command: "
  err_pipe(){ while IFS='' read -r msg; do msg="$1$msg"; ((LogLevel >= 0)) && printf '%s\n' "$msg" >> "$LogFile"; done; }

else
  printf "$ERROR_CLR %s\n" 'The LogType option, if provided, must be one of: "file"; "stdout"; "stderr"; "filestdout"; "filestderr".'
  return 1
fi


# #TODO: Add function for setting debug trace, or make this a stand alone script
# #Prepend output with a "Simple" OR "Detailed" 
# pre="$1"
# #Send trace output to file
# exec 5> "$m2kdir/${FileNameNow}_debug_trace.log"
# BASH_XTRACEFD="5"
# if [ "$pre" = "Simple" ] ; then
#   PS4='${0}:${LINENO}: '
# elif [[ "$pre" = "Detailed" ]]; then
# 	PS4='(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]} - [${SHLVL},${BASH_SUBSHELL}, $?]'$'\n'
# else
# 	{ printf "$ERROR_CLR %s\n" "Prepend arg must be ['Simple' | 'Detailed'] eg: ${BASH_SOURCE[0]} 'Detailed'" ; return 1 ; }
# fi
# set -x
#
#
#
#
# #Then after we've finished using the file-descriptor we should close it
# #Close fd # 5
# exec 5<&-
#
#

# #Make the functions defined here readonly to prevent clobbering by calling script.
# readonly -f Debug
# readonly -f Inform
# readonly -f Warn
# readonly -f Err
# readonly -f DebugCont
# readonly -f InformCont
# readonly -f WarnCont
# readonly -f ErrCont
return 0
