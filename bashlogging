#! /bin/bash

#USAGE:
#  #Source the file to get access to all the variable and function definitions.
#  source bashlogging [LogType]
#  #the optional LogType argument ['stdout'|'logfile'|'both'(default)] directs
#  # output to stdout, file or both. this can only be set while "source"ing.
#  #Then you can override default LogFile and LogLevel to suit your needs.
#  LogFile='path/to/mylogfile.log'
#  LogLevel=3  #I have a problem with my script that I need to identify.
#  myfunc(){
#    #Then all that is left is to cover your script and functions with 
#    #useful messages:
#    Debug "ENTERING: ${FUNCNAME}()"
#    Inform 'That important thing is being calculated now...'
#    Warn 'The ducks weren't all in a row, but we'll forge on.'
#    Err 'It all went horribly wrong, no value will be returned.'
#    ErrCont "The value of x was y and j was z, try passing q to ${FUNCNAME}()"
#    ErrCont 'You might also need to chmod yourfile.txt and do a rain dance.'
#  }
#
#REQUIRES:
#  tee -- reads from standard input and write to standard output and files
#  xargs
#  bash >= 4
#
#PROVIDES (all functions are tagged READONLY):
#  #Message functions: for file output, prepends date & time
#  Debug  -- For LogLevel >= 3, writes messages prepended with "DEBUG: "
#  Inform -- For LogLevel >= 2, writes messages prepended with "INFORM: "
#  Warn   -- For LogLevel >= 1, writes messages prepended with "WARNING: "
#  Err    -- For LogLevel >= 0, writes messages prepended with "ERROR: "
#  #Continued/multiline message functions: these are indented without leading info.
#  DebugCont  -- Continues a LogLevel 3 message.
#  InformCont -- Continues a LogLevel 2 message.
#  WarnCont   -- Continues a LogLevel 1 message.
#  ErrCont    -- Continues a LogLevel 0 message.
#
#DESCRIPTION:
# Defines a few functions for fine grained control of logging information.
# Writes different types of messages based on LogLevel. The messages are 
# sent to either stdout, file, or both based on the LogType argument. The
# file output is prepended with date & time -- stdout isn't.
#
# Author: Stuart A. Knock
# Originally Written: 2015-11-27
#

#TODO: Consider adding an AutoElevate ['Enabled'|'Disabled'] option, which automatically raises 
#      the LogLevel to 2 in the event of warnings and 3 in the event of errors.
#TODO: Consider making the function names more explicit by prepending Log
#TODO: Consider colourising the terminal part of the output.
#    redtxt='\e[0;31m' # Red
#    grntxt='\e[0;32m' # Green
#    ylwtxt='\e[0;33m' # Yellow-ish
#    blutxt='\e[0;34m' # Blue
#    redbld='\e[1;31m' # Bold Red
#    grnbld='\e[1;32m' # Bold Green
#    ylwbld='\e[1;33m' # Bold Yellow-ish
#    blubld='\e[1;34m' # Bold Blue
#    clrreset='\e[0m'
#  then use,
#    "${redbld}ERROR:${clrreset} "
#    "${ylwbld}WARNING:${clrreset} "
#    "${blubld}INFO:${clrreset} "
#    "${grnbld}DEBUG:${clrreset} "
#  so,
#    printf '${redtxt}ERROR:${clrreset} %s\n'   "message"
#  NOTE: will need to strip them when sending to file...
#    sed -r "s/\x1B\[([0-1];)?[0-4]{1,2}m//g"
#TODO: Consider making indentation on Cont[inuation] lines a standard 4 spaces.
#TODO: Enable different "LogLevel"s for file and stdout.

#Default logging level, controls the type of bashlogging messages reported.
#This can be modified at any point in a calling script to increase/decrease
#the amount of information reported based on context.
#    0=Only Errors;
#    1=adds warnings;
#    2=adds more information;
#    3=provides debugging output.
declare -i LogLevel=2

#Default log file name, 
LogFile='default_bashlogging.log'

#Default type of logging to do, or more specifically the type of destination
#for logging messages. Options are ['logfile'|'stdout'|'both'(default)], the
#default set here can only be overridden when source[ing] bashlogging, eg:
#    source bashlogging 'logfile' #Only send logging messages to file, not stdout.
#and not after sourcing, as can be done with LogLevel and LogFile.
LogType='both'

#^^^^----------- DEFAULT USER SETTINGS ABOVE THIS LINE ------------------^^^^#


#The type of logging to do, or more specifically the type of destination for messages.
#The options are 'both'[default] | 'logfile' | 'stdout'
(($# > 1)) && { printf '${redbld}ERROR:${clrreset} %s\n' "$0 take only 1 arg" ; exit 1 ; }
(($# == 1)) && declare -r LogType=$1 || declare -r LogType

declare -r pad='           ' #needs to be >= number of spaces for the largest X below in %0.Xs
declare -r redbld='\e[1;31m' # Bold Red
declare -r grnbld='\e[1;32m' # Bold Green
declare -r ylwbld='\e[1;33m' # Bold Orange-ish
declare -r blubld='\e[1;34m' # Bold Blue
declare -r clrreset='\e[0m'  # Resets the colour to default

if [ "$LogType" = "both" ] ; then
  #Functions defining the different logging messages, sent to logfile & stdout
  #sleep is a hack to avoid wrong order in file when *Cont is used, and apparently processes faster leading to out of order file content. Maybe put in start of *Cont???
  Debug(){  ((LogLevel >= 3)) && printf "${grnbld}DEBUG:${clrreset} %s\n"   "$1" | tee >(xargs --null printf "[$(date +%FT%T)] %s" | sed -r "s/\x1B\[([0-1];)?[0-4]{1,2}m//g" >> $LogFile); sleep 0.002; }
  Inform(){ ((LogLevel >= 2)) && printf "${blubld}INFO:${clrreset} %s\n"    "$1" | tee >(xargs --null printf "[$(date +%FT%T)] %s" | sed -r "s/\x1B\[([0-1];)?[0-4]{1,2}m//g" >> $LogFile); sleep 0.002; }
  Warn(){   ((LogLevel >= 1)) && printf "${ylwbld}WARNING:${clrreset} %s\n" "$1" | tee >(xargs --null printf "[$(date +%FT%T)] %s" | sed -r "s/\x1B\[([0-1];)?[0-4]{1,2}m//g" >> $LogFile); sleep 0.002; }
  Err(){    ((LogLevel >= 0)) && printf "${redbld}ERROR:${clrreset} %s\n"   "$1" | tee >(xargs --null printf "[$(date +%FT%T)] %s" | sed -r "s/\x1B\[([0-1];)?[0-4]{1,2}m//g" >> $LogFile); sleep 0.002; }
  #Func: #Checks LogLevel is appropriate #Prepends msg with Type     #Pipes to stdout & Command as fake file: prepend Date&Time then Strip colour tags           #Redirect to log file  #Wait so order preserved

  #Use for multiple lines of a single message, sent to logfile & stdout
  DebugCont(){  ((LogLevel >= 3)) && printf '%0.7s%s\n' "$pad" "$1" | tee -a $LogFile; }
  InformCont(){ ((LogLevel >= 2)) && printf '%0.6s%s\n' "$pad" "$1" | tee -a $LogFile; }
  WarnCont(){   ((LogLevel >= 1)) && printf '%0.9s%s\n' "$pad" "$1" | tee -a $LogFile; }
  ErrCont(){    ((LogLevel >= 0)) && printf '%0.7s%s\n' "$pad" "$1" | tee -a $LogFile; }

elif [ "$LogType" = "stdout" ] ; then
  #Functions defining the different logging messages, no-logfile==only-stdout
  Debug(){  ((LogLevel >= 3)) && printf '${grnbld}DEBUG:${clrreset} %s\n'   "$1" ; }
  Inform(){ ((LogLevel >= 2)) && printf '${blubld}INFO:${clrreset} %s\n'    "$1" ; }
  Warn(){   ((LogLevel >= 1)) && printf '${ylwbld}WARNING:${clrreset} %s\n' "$1" ; }
  Err(){    ((LogLevel >= 0)) && printf '${redbld}ERROR:${clrreset} %s\n'   "$1" ; }

  #Use for multiple lines of a single message, no-logfile==only-stdout
  DebugCont(){  ((LogLevel >= 3)) && printf '%0.7s%s\n' "$pad" "$1" ; }
  InformCont(){ ((LogLevel >= 2)) && printf '%0.6s%s\n' "$pad" "$1" ; }
  WarnCont(){   ((LogLevel >= 1)) && printf '%0.9s%s\n' "$pad" "$1" ; }
  ErrCont(){    ((LogLevel >= 0)) && printf '%0.7s%s\n' "$pad" "$1" ; }

elif [ "$LogType" = "logfile" ] ; then
  #Functions defining the different logging messages, no-stdout==only-logfile
  Debug(){  ((LogLevel >= 3)) && printf "[$(date +%FT%T)] DEBUG: %s\n"   "$1" >> $LogFile; }
  Inform(){ ((LogLevel >= 2)) && printf "[$(date +%FT%T)] INFO: %s\n"    "$1" >> $LogFile; }
  Warn(){   ((LogLevel >= 1)) && printf "[$(date +%FT%T)] WARNING: %s\n" "$1" >> $LogFile; }
  Err(){    ((LogLevel >= 0)) && printf "[$(date +%FT%T)] ERROR: %s\n"   "$1" >> $LogFile; }

  #Use for multiple lines of a single message, no-stdout==only-logfile
  DebugCont(){  ((LogLevel >= 3)) && printf '%0.7s%s\n' "$pad" "$1" >> $LogFile; }
  InformCont(){ ((LogLevel >= 2)) && printf '%0.6s%s\n' "$pad" "$1" >> $LogFile; }
  WarnCont(){   ((LogLevel >= 1)) && printf '%0.9s%s\n' "$pad" "$1" >> $LogFile; }
  ErrCont(){    ((LogLevel >= 0)) && printf '%0.7s%s\n' "$pad" "$1" >> $LogFile; }

else
  printf '${redbld}ERROR:${clrreset} %s\n' 'The LogType option, if provided, must be one of: "both"; "logfile"; "stdout".'
  exit 1
fi

# #Make the functions defined here readonly to prevent clobbering by calling script.
# readonly -f Debug
# readonly -f Inform
# readonly -f Warn
# readonly -f Err
# readonly -f DebugCont
# readonly -f InformCont
# readonly -f WarnCont
# readonly -f ErrCont
# exit 0
